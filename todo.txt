Test-DONE
=========

+ sub_if_gte (avoid branches/if ...)  +small enh+ (also needed for vectors)
- __local tmps instead of res->... intermediates?  - no effect -
- inline small functions (automatically done)
- divergent branches (bad, bad, bad)
- select vs. "... ? ... : ..." 
+ 3x24-bit kernel
- ((x<<8)>>8) instead of (x&0xFFFFFF)   (found in the forum) : no difference at all!
+ loop-unroll: OK, 64-loop in mod: unrolled 10% faster on GPU, no (big) change on CPU
+ vectorize (4 FC's at once?)
+ mad(ulong, ...) runs implicit I_TO_F + MULADD_e (float) ... SLOW!!!
+ hi= (hi << 1) + ((lo & 0x8000000000000000) ? 1 : 0) faster than (hi<<1)+(lo>>63ULL)

Test-TODO
=========
- 4x24-bit kernel
- in mod144_72: if q.d5!=0 ... will most likely skip the first block for one in 19 executions. Is that worth it?


TODO
====
+DONE+ - only set new params for subsequent kernel-runs
+DONE+ - cleanup mystuff
+DONE+ - cleanup cuda
+DONE+ - cleanup kernel file => test-kernel
+DONE+ - cleanup AMD licensed stuff
+DONE+ - KERNEL trace only the first thread
+DONE+ - check limits for 95-bit kernel
+DONE+ - add 64-bit kernel
+DONE+ - port 72 (3x24 bit) kernel
+DONE+ - call 72-bit kernel correctly
+DONE+ - port barrett kernels (div, mul, mod)
+DONE+ - create a kernel struct: name, cl_kernel_id, bit_min, bit_max
+DONE+ - save a copy / rev control
+DONE+ - re-enable auto-adjust of sieve-limit (measure wait-time)
+DONE+ - signal handler
+DONE+ - max 128 threads per block ... needed at all?
+DONE+ - --help
+DONE+ - complain about bad args
+DONE+ - calibrate auto-adjust
+DONE+ - cleanup unused kernels and kernel functions
+DONE+ - make it run on 11.10 / 11.11
+DONE+ - save copy of cpt file
+DONE+ - use old copy of cpt file if necessary
+DONE+ - allow running multiple instances in the same dir (all parameters as options)
+DONE+ - allow cpts only after some classes
+DONE+ - -d g
+DONE+ - "restrict" "const" wherever possible
+DONE+ - merge mfaktc 0.18
+DONE+ - allow reading ckp's of other versions (now even mfaktc)
+DONE+ - optimize 72-bit kernel for small vs. large factors (skip some converts depending on the size)
+DONE+ - result format changes
+DONE+ - versioning for txt files
- make/allow for small exps/bit-levels
- verify factors using the modulo-kernels and clEnqueueTask 
- http://mersenneforum.org/showpost.php?p=258140&postcount=7 trialfactor_72.cl
- div/mul-modulo for 96 bits
- kernel trace more specific (bitmask)
- 4 threads - 4 classes at once - also in host code to maximize GPU-utilization in a single program
- error handling: RES[0] -= 100; save up to 3 ints in RES; only in single-vec
- MODBASECASE_NN_BIG_ERROR in mod_144_72
- clGetKernelWorkGroupInfo in load kernels: preferred size, local mem
- evaluate max mem alloc (device info)
- serialize memory access for vector kernels
- AllowSleep
- perftest modes for sieving (SIEVE_SIZE), data copy and kernel speed.
- test optimisation options on Linux
- retrieve L1/L2-cache-size and optimize sieve accordingly at runtime
- GPU-sieve: classes on CPU. k-min, k-max, p  ==> GPU ==> last-k, RES
  issues: sieve-init without div/mod
          memory access pattern during sieving ... workgroup size 64: p6-p70 in one group, after that diminishing differences in loop time.
